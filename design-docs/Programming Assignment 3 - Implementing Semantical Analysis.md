# Programming Assignment 3 - Implementing Semantical Analysis

## Collaborators
* Michael Maitland, mtm68
* Scott Bass, sb2383
* Michael Tobin, mat292

## Running the Program

**Main class:** `mtm68.Main.java`

Run `xic-build` (this requires having Maven installed). Then `xic [options...] <source-files>` becomes available.

## Summary



## Specification

The following are choices we made regarding specification...

One choice is that indexing into an empty array initializer will not pass type checking (i.e. {}[0]). We made this choice as allowing it would cause a decent deal of redesign in our current type implementation and it semantically does not make sense anyway. Such an access would always lead to an out of bounds exception down the line, therefore, having it fail during semantic analysis should not have any bearing on user convenience.

**INSERT**

## Design and Implementation 

### Architecture ###
The key classes and packages we created or updated for this assignment are the following...
 
- mtm68.Main.java
    - Our Main functions very similarly to the previous assignment. We added new options to the command line as described in the spec. We also added type checking to the source file pipeline. 
 				  
- mtm68.SymbolTableManager
    - This class organizes interface imports and merges all relevant interface function declarations into a symbol table. It maintains a map of "use ids" to maps of "function names" to "function declarations". By organizing it this way, we do not have to lex and parse the same interface files repeatedly if multiple .xi files use them. The info is stored in this map and can be accessed multiple times. Here, there are also checks to ensure that functions with the same name are consistent across multiple interface files. Upon given a program, the SymbolTableManager accesses each Use object and either looks up the .ixi file in the libpath or pulls the info from .ixi files that were passed as source files to the compiler.
    
- mtm68.visit.Visitor.java
    - We decided to use the Visitor pattern for AST passes. This class is the very basic parent of all visitors we create.
    
- mtm68.visit.Visitor.TypeChecker
    - This is the visitor that actually carries out the type checking of the AST. The TypeChecker "enters" a node, visits its childrens, and then typechecks as it performs "leave". We typecheck in the leave method as, at this point, all of the children will have been typechecked and tagged with their corresponding types. Therefore, we have all the info we need to typecheck the current node. The TypeChecker is given the initial symbol table generated by SymbolTableManager (above) and FunctionCollector (below). From there the TypeChecker constructs and maintains a TypingContext (below) to access as outlined in the type spec. As the TypeChecker visits nodes, it maintains a list of errors that is added to whenever there is a non-fatal type error. This allows us to continue checking even if there are errors. Fatal errors are errors generally where bindings are ambiguous in the context.
    
- mtm68.visit.FunctionCollector
    - As mentioned in the type spec, type checking requires two passes as functions can be mutually recursive. The FunctionCollector is a Visitor who's purpose is to simply collect function declarations and add them to a symbol table prior to typechecking. This collection happens after SymbolTableManager merges interface tables. The FunctionCollector collects errors (similar to TypeChecker) if a function is declared multiple times in the source file or there is a mismatch between a source file function declaration and an interface function declaration. The FunctionCollector then merges the table it creates with the table from SymbolTableManager which creates the starting typing context.
    
- mtm68.types.TypingContext
    - This class maintains the typing context for type checking. It is instantiated with the symbol table generated by FunctionCollector. It maintains a stack of Maps from ids to ContextTypes (below). It has a number of documented helper methods to interface with it. It supports entering and leaving scopes by pushing and popping off the stack respectively. 
    
- mtm68.types.ContextType
   - A ContextType stores type information as it is used in the TypingContext. A ContextType can fall into two categories. The first is a simple variable to type binding. The other is a function name to arg types and return types. 
    
### Code Design ###
- For this assignment, we highly leveraged the Visitor design pattern in order to create AST passes. We were inspired by the polyglot visitor and created a similar Visitor that allowed for lazy tree creation. We believe this will be extremely useful in later assignments when we have many passes to implement (whether it be representation translation or optimization). Having an immutable copy of the tree after each pass will allow for easier debugging.
- As discussed in lecture, a key data structure we used in this assignment is a stack (or techincally a Deque) of maps for our typing context. We decided to go this route for its ease of implementation despite it not being the most efficient method discussed in class. Maps, in general, were very important in this section due to the number of cases they were suited for (discussed in architecture section).

### Programming ###
- Luckily this time, we did not run into any build errors. The most challenging aspect was organizing our code and AST in order to accomodate the new Visitor pattern we were using. This required analyzing each node and how its children should be visited. We also had to concern ourselves with copying nodes in order to preserve the immutability of our AST (which we got wrong a few times at first). 
- The following is the team coding/responsibility breakdown for this assignment...
    - **Tobin:** 
       - parser fixes + tests
       - SymbolTableManager
       - FunctionCollector + tests
       - TypingContext
       - Function TypeChecking + tests
    - **Maitland:**
        - lexer fixes + tests
        - Visitor + TypeChecker
        - Expr typechecking + tests
    - **Bass:**
        - TypeChecker
        - Statement typechecking + tests
        - Error output/handling
 - We leveraged our lexer and parser code from previous assignments. We did have to make a few fixes but most were due to pretty print differences or error location reporting.
 
## Testing


## Work plan



## Known Problems

We currently are not aware of any issues with our compiler.

## Comments

NA

