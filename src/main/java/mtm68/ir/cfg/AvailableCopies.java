package mtm68.ir.cfg;

import java.io.IOException;
import java.io.Writer;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import edu.cornell.cs.cs4120.ir.IRExpr;
import edu.cornell.cs.cs4120.ir.IRFuncDefn;
import edu.cornell.cs.cs4120.ir.IRMove;
import edu.cornell.cs.cs4120.ir.IRSeq;
import edu.cornell.cs.cs4120.ir.IRStmt;
import edu.cornell.cs.cs4120.ir.IRTemp;
import mtm68.assem.cfg.Graph;
import mtm68.assem.cfg.Graph.Node;
import mtm68.ir.cfg.IRCFGBuilder.IRData;
import mtm68.util.SetUtils;

public class AvailableCopies {

	private Graph<IRData<AvailableCopyData>> graph;
	private IRCFGBuilder<AvailableCopyData> builder;
	
	private IRFuncDefn ir;

	public AvailableCopies(IRFuncDefn ir) {
		builder = new IRCFGBuilder<>();
		this.ir = ir;
	}
	
	public void performAnalysis() {

		IRStmt body = ir.body();
	    List<IRStmt> stmts = ((IRSeq)body).stmts();

		graph = builder.buildIRCFG(stmts, AvailableCopyData::new);
		List<Node> nodes = graph.getNodes();
		
		boolean changes = true;
		while (changes) {
			changes = false;
			
			for(Node node : nodes) {
				IRData<AvailableCopyData> data = graph.getDataForNode(node);
				AvailableCopyData flowData = data.getFlowData();
				
				Set<AvailableCopy> inOld = flowData.getIn();
				Set<AvailableCopy> outOld = flowData.getOut();
				
				Set<AvailableCopy> in = in(node);
				Set<AvailableCopy> out = out(node);
				
				flowData.setIn(in);
				flowData.setOut(out);
				
				flowData.isTop = false;
				changes = changes || (!inOld.equals(in) || !outOld.equals(out));
			}
		}
	}
	
	/**
	 * The set of definitions reaching a node.
	 * in[n] = definitions reaching on all edges into n.
	 */
	private Set<AvailableCopy> in(Node node) {
		Set<AvailableCopy> in = SetUtils.empty();
		boolean first = true;
		for(Node pred : node.pred()) {
			AvailableCopyData predData = graph.getDataForNode(pred)
											   .getFlowData();
			
			Set<AvailableCopy> out = predData.getOut();
			/**
			* The first iteration, we need to set the base set 
			* because intersect with empty set will always be empty
			* and there is no good way to set the initial set
			* as the empty set
			*/
			if(predData.isTop) continue;
			if(first) {
				in = SetUtils.copy(out);
				first = false;
			} else {
				in = SetUtils.intersect(in, out);
			}
		}
		
		return in;
	}

	/**
	 * The set of available expressions on edges leaving node n.
	 * out[n] = gen[n] U (in(n) - kill(n))
	 */
	 private Set<AvailableCopy> out(Node n) {

		Set<AvailableCopy> gen = gen(n);
		Set<AvailableCopy> in = in(n);
		Set<AvailableCopy> kill = kill(n, in);
		
		Set<AvailableCopy> difference = SetUtils.difference(in, kill);
		 
		return SetUtils.union(gen , difference);
	 }
	 
	/**
	 * Definitions generated by a node.
	 * 
	 * For example,
	 * gen(x <- y) = node 
	 * else 	   = {}
	 */
	private Set<AvailableCopy> gen(Node node) {
		IRStmt ir = graph.getDataForNode(node).getIR();

		if (hasXGetsYForm(ir)) {
			return genXGetsY((IRMove)ir, node);

		} else {
			return SetUtils.empty();
		}
	}

	private Set<AvailableCopy> genXGetsY(IRMove mov, Node d) {
		IRTemp x = (IRTemp)mov.target();
		IRTemp y = (IRTemp)mov.source();

		if(y.name().startsWith("_RET"))
			return SetUtils.empty();
		
		if(y.name().startsWith("_ARG"))
			return SetUtils.empty();
		
		AvailableCopy defn = new AvailableCopy(x, y, d);

		return SetUtils.elems(defn);
	}

	/**
	 * Expressions killed by a node that has facts l.
	 * 
	 * For example,
	 * kill(x <- e)    = x = z, z = x forall z
	 * else		       = {}	
	 * 
	 */
	private Set<AvailableCopy> kill(Node node, Set<AvailableCopy> l) {
		IRStmt ir = graph.getDataForNode(node).getIR();

		if (hasXGetsEForm(ir)) {
			return killXGetsE((IRMove)ir, l);

		} else {
			return SetUtils.empty();
		}
	}
	
	/**
	 * The subset of l that contains IRTemp t.
	 * @param ir of the form IRMove(IRTemp t, IRExpr)
	 */
	private Set<AvailableCopy> killXGetsE(IRMove ir, Set<AvailableCopy> l) {
		IRTemp temp = (IRTemp)ir.target();
		return l.stream()
				.filter(r -> r.x.equals(temp) || r.y.equals(temp))
				.collect(Collectors.toSet());
	}

	private boolean hasXGetsYForm(IRStmt ir) {
		return ir instanceof IRMove 
				&& ((IRMove)ir).target() instanceof IRTemp
				&& ((IRMove)ir).source() instanceof IRTemp;
	}
	
	private boolean hasXGetsEForm(IRStmt ir) {
		return ir instanceof IRMove 
				&& ((IRMove)ir).target() instanceof IRTemp
				&& ((IRMove)ir).source() instanceof IRExpr;
	}

	public Graph<IRData<AvailableCopyData>> getGraph() {
		return graph;
	}
	
	public void showGraph(Writer writer) throws IOException {
		graph.show(writer, "AvailableExpressions", true, this::showAvailable);
	}
	
	public IRCFGBuilder<AvailableCopyData> getBuilder() {
		return builder;
	}

	private String showAvailable(IRData<AvailableCopyData> data) {
		Set<AvailableCopy> in = data.getFlowData().getIn();
		Set<AvailableCopy> out = data.getFlowData().getOut();
		IRStmt ir = data.getIR();

		StringBuilder sb = new StringBuilder();

		sb.append("In: ");
		sb.append(setToString(in));
		sb.append("\\n");
		
		sb.append(ir.toString());
		sb.append("\\n");

		sb.append("Out: ");
		sb.append(setToString(out));

		return sb.toString();
	}
	
	private <T> String setToString(Set<T> set) {
		StringBuilder sb = new StringBuilder();
		sb.append('{');
		
		String elems = set.stream()
			.map(Object::toString)
			.collect(Collectors.joining(","));

		sb.append(elems);

		sb.append('}');
		
		return sb.toString();
	}
	
	public static class AvailableCopyData {
		Set<AvailableCopy> in;
		Set<AvailableCopy> out;
		boolean isTop = true;
		
		public AvailableCopyData() {
			in = SetUtils.empty();
			out = SetUtils.empty();
		}

		public Set<AvailableCopy> getIn() {
			return in;
		}

		public void setIn(Set<AvailableCopy> in) {
			this.in = in;
		}

		public Set<AvailableCopy> getOut() {
			return out;
		}

		public void setOut(Set<AvailableCopy> out) {
			this.out = out;
		}
	}

	public static class AvailableCopy {
		IRTemp x;
		IRTemp y;
		Node definer;
		
		// Node n defines x = y
		public AvailableCopy(IRTemp x, IRTemp y, Node definer) {
			this.x = x;
			this.y = y;
			this.definer = definer;
		}
		
		public Node getDefiner() {
			return definer;
		}
		public void setDefiner(Node definer) {
			this.definer = definer;
		}
		
		public IRTemp getX() {
			return x;
		}

		public void setX(IRTemp x) {
			this.x = x;
		}

		public IRTemp getY() {
			return y;
		}

		public void setY(IRTemp y) {
			this.y = y;
		}

		public String toString() {
			return definer.getNodeId() + "";
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((definer == null) ? 0 : definer.hashCode());
			result = prime * result + ((x == null) ? 0 : x.hashCode());
			result = prime * result + ((y == null) ? 0 : y.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			AvailableCopy other = (AvailableCopy) obj;
			if (definer == null) {
				if (other.definer != null)
					return false;
			} else if (!definer.equals(other.definer))
				return false;
			if (x == null) {
				if (other.x != null)
					return false;
			} else if (!x.equals(other.x))
				return false;
			if (y == null) {
				if (other.y != null)
					return false;
			} else if (!y.equals(other.y))
				return false;
			return true;
		}
	}
}
