// A stub for a Xi CUP specification.

package mtm68.parser;
import mtm68.ast.nodes.*;
import mtm68.ast.types.*;
import mtm68.ast.nodes.binary.*;
import mtm68.exception.*;
import java.util.*;

// You might want to add types to these declarations.
terminal String ID;
terminal String STRING;
terminal Character CHARACTER;
terminal Long INTEGER;
terminal FUNAPP;
terminal INDEX;

terminal USE, IF, ELSE, WHILE, RETURN, LENGTH, INT, BOOL, TRUE, FALSE; 
terminal OPEN_SQUARE, CLOSE_SQUARE, OPEN_PAREN, CLOSE_PAREN, OPEN_CURLY, CLOSE_CURLY,
	EXCLAMATION, COLON, SEMICOLON, COMMA, EQ, UNDERSCORE;
terminal ADD, SUB, MULT, DIV, MOD, HIGH_MULT, LT, LEQ, GT, GEQ, EQEQ, NEQ, AND, OR, UMINUS; 

// You might want to add types to these declarations.
nonterminal prog;
nonterminal top;
nonterminal interface;
nonterminal use_star;
nonterminal fdecl_star;
nonterminal fdefn_plus;
nonterminal Expr exp;
nonterminal FExpr fexp;
nonterminal List<Expr> exp_star;
nonterminal List<Expr> exp_plus;
nonterminal List<Expr> array_init;
nonterminal decl;
nonterminal opt_decl;
nonterminal opt_decl_wild;
nonterminal multiple_assign;
nonterminal decl_list;
nonterminal Type ty;
nonterminal DeclType ty_decl;
nonterminal ty_list;
nonterminal f_type;
nonterminal fdecl;
nonterminal fdefn;
nonterminal stmt;
nonterminal stmt_list;
nonterminal return_stmt;
nonterminal assignment;
nonterminal block;
nonterminal stmt_list_ret;
nonterminal opt_comma;

// Add more nonterminals here...

precedence left OR;
precedence left AND;
precedence left EQEQ, NEQ;
precedence left LT, LEQ, GEQ, GT;
precedence left ADD, SUB;
precedence left MULT, HIGH_MULT, DIV, MOD;
precedence left UMINUS, EXCLAMATION;
precedence left FUNAPP, INDEX;

precedence nonassoc IF;
precedence nonassoc ELSE;

// HACKY???
precedence right COMMA;

start with ty_decl;

//program ::= USE;

//top ::= XI prog
//    | IXI interface
//    ;

prog ::= use_star fdefn_plus
;

interface ::= fdecl_star
;

use_star ::= /* epsilon */
    | USE ID use_star
    | USE ID SEMICOLON use_star
    ;

fdecl_star ::= /* epsilon */
    | fdecl fdecl_star
    ;

fdefn_plus ::= fdefn
    | fdefn fdefn_plus
    ;

exp ::= exp:e1 OR exp:e2           {: RESULT = new Or(e1, e2); :}
    | exp:e1 AND exp:e2            {: RESULT = new And(e1, e2); :}
    | exp:e1 EQEQ exp:e2           {: RESULT = new EqEq(e1, e2); :}
    | exp:e1 NEQ exp:e2            {: RESULT = new NotEqual(e1, e2); :}
    | exp:e1 LT exp:e2             {: RESULT = new LessThan(e1, e2); :}
    | exp:e1 LEQ exp:e2            {: RESULT = new LessThanOrEqual(e1, e2); :}
    | exp:e1 GEQ exp:e2            {: RESULT = new GreaterThanOrEqual(e1, e2); :}
    | exp:e1 GT exp:e2             {: RESULT = new GreaterThan(e1, e2); :}
    | exp:e1 ADD exp:e2            {: RESULT = new Add(e1, e2); :}
    | exp:e1 SUB exp:e2            {: RESULT = new Sub(e1, e2); :}
    | exp:e1 MULT exp:e2           {: RESULT = new Mult(e1, e2); :}
    | exp:e1 HIGH_MULT exp:e2      {: RESULT = new HighMult(e1, e2); :}
    | exp:e1 DIV exp:e2            {: RESULT = new Div(e1, e2); :}
    | exp:e1 MOD exp:e2            {: RESULT = new Mod(e1, e2); :}
    | SUB exp:e                    {: RESULT = new Negate(e); :}  %prec UMINUS
    | EXCLAMATION exp:e            {: RESULT = new Not(e); :}  %prec EXCLAMATION
    | INTEGER:n                    {: RESULT = new IntLiteral(n); :}
    | fexp:e                       {: RESULT = e; :} %prec FUNAPP
    | exp:e1 OPEN_SQUARE exp:e2 CLOSE_SQUARE {: RESULT = new ArrayIndex(e1, e2); :} %prec INDEX 
    | ID:id                        {: RESULT = new Var(id); :}
    | OPEN_PAREN exp:e CLOSE_PAREN   {: RESULT = e; :}
    | OPEN_CURLY array_init:args CLOSE_CURLY {: RESULT = new ArrayInit(args); :}
    | TRUE                         {: RESULT = new BoolLiteral(true); :}
    | FALSE                        {: RESULT = new BoolLiteral(false); :}
    | CHARACTER:c                  {: RESULT = new CharLiteral(c); :}
    | STRING:s                     {: RESULT = new StringLiteral(s); :}
    | LENGTH OPEN_PAREN exp:e CLOSE_PAREN {: RESULT = new ArrayLength(e); :}
    ;

fexp ::= ID:id OPEN_PAREN exp_star:args CLOSE_PAREN     {: RESULT = new FExpr(id, args); :} 
;

exp_star ::= /* epsilon */  {: RESULT = new ArrayList<Expr>(); :}
    | exp_plus:e            {: RESULT = e; :}
    ;

exp_plus ::= exp:e               {: List<Expr> list = new ArrayList<Expr>();
                                    list.add(e);
                                    RESULT = list; :}
    | exp_plus:es COMMA exp:e    {: es.add(e); RESULT = es; :}
    ;

array_init ::= /* epsilon */           {: RESULT = new ArrayList<Expr>(); :}
    | exp_plus:e opt_comma             {: RESULT = e; :}
    ;

opt_comma ::= /* epsilon */
    | COMMA
    ;

// x:int
decl ::= ID COLON ty
;

// x:int
// x
opt_decl ::= ID
    | decl
    ;

// x:int
// x
// _
opt_decl_wild ::= opt_decl | UNDERSCORE;

// x:int, y:int = f()
// x, y = f()
// x:int, y = f()
// _, y:int = f()
multiple_assign ::= opt_decl_wild COMMA opt_decl_wild
    | opt_decl_wild COMMA multiple_assign
    ;

decl_list ::= decl
    | decl COMMA decl_list
    ;

ty ::= INT                            {: RESULT = Types.INT; :}
    | BOOL                            {: RESULT = Types.BOOL; :}
    | ty:t OPEN_SQUARE CLOSE_SQUARE   {: RESULT = Types.ARRAY(t); :}
    ;

ty_decl ::= INT                                  {: RESULT = new DeclType(Types.INT); :}
    | BOOL                                       {: RESULT = new DeclType(Types.BOOL); :}
    | ty_decl:t OPEN_SQUARE exp:e CLOSE_SQUARE   {: if(t.canAddMoreIndices()) { t.addArrayLayer(); t.addIndexExpr(e); RESULT = t; }
                                                    else { report_error("Invalid array indices in decl", null); RESULT = t; } :}
    | ty_decl:t OPEN_SQUARE CLOSE_SQUARE         {: t.addArrayLayer(); RESULT = t; :}
    ;

ty_list ::= ty
    | ty COMMA ty_list
    ;

// sort(x: int[]) { ... }
// gcd(a: int, b : int) : int, bool { ... }
f_type ::= /* epsilon */
    | COLON ty_list
    ;

fdecl ::= ID OPEN_PAREN decl_list CLOSE_PAREN f_type 
;

fdefn ::= fdecl block 
;

stmt ::= assignment
    | IF exp stmt 
    | IF exp stmt ELSE stmt
    | WHILE exp stmt 
    | fexp
    | decl
    | block
    ;

stmt_list ::= /* epsilon */
    | stmt stmt_list
;

return_stmt ::= RETURN exp_star
;

// TODO: reduce-reduce 
// ID EQ . fexp
assignment ::= opt_decl EQ exp
    | multiple_assign EQ fexp
    ;

block ::= OPEN_CURLY stmt_list_ret CLOSE_CURLY
;

// TODO: shift-reduce
stmt_list_ret ::= stmt_list
    | stmt_list return_stmt
    ;
